正则表达式匹配（注意 '*' 的情况，三种情况）
最长回文子串（中心扩散解法和动态规划解法）
全排列2
电话号码的字母组合
复原IP
分割回文串
回溯中的去重(树层去重和树枝去重)
N皇后
递增子序列(去重)
括号生成
三数之和
下一个排列
不同路径2，有障碍物如何进行初始化及状态转移
不同的二叉搜索树，如何构建转移方程
分割等和子集（体会将物品的价值和重量都设为数组元素的值，能否找到背包的最大值 等于 背包的重量）
目标和（如何将题目转化成01背包问题求解）
一和零（确定dp数组及其含义）
零钱兑换2（两层循环顺序是否可以调换）
组合总和4（背包问题，求组和 物品在外循环，背包在内循环， 求排列 背包在外循环，物品在内循环）
单词拆分（注意循环顺序）
打家劫舍2（成环该如何考虑，分类）
股票买卖系列（dp数组的含义理解）
最佳买卖股票时机含冷冻期（注意初始化）
最长重复子数组（滚动数组法中DP数组的含义，可以研究一下滑动窗口法）
不相交的线（将其转换成最长公共子序列问题）
不同的子序列（dp数组的含义，递推公式的推导，如何进行初始化）
回文子串（dp数组的含义，遍历顺序， 中心扩散解法）
最长回文子序列（dp数组的含义，遍历顺序）
二叉树的最小深度（注意最小深度的判断条件，需要是叶子节点）
完全二叉树的节点个数（如何利用完全二叉树的特点，找到满二叉树的子树，利用公式计算节点个数）
平衡二叉树（如何利用二叉树的深度求解解决，使用后序遍历的思想避免重复计算）
二叉树的所有路径（to_string函数，回溯的终止条件，迭代法的理解，dfs的解法）
左叶子之和（理解返回值return curvalue + leftvalue + rightvalue）
找树左下角的值（理解递归终止条件，理解递归和回溯两种方法）
通过中序和后序遍历构造二叉树（弄清楚边界处理）

二叉搜索树：与中序遍历绑定思考

验证二叉搜索树（不能单一的判断左右子节点和父节点的值的大小，利用中序遍历，在遍历过程中比较）
二叉搜索树的最小绝对差（声明一个变量pre用于保存上一个节点）
二叉搜索树中的众数（利用pre保存上一个节点进行比较，利用全局变量记录个数和最大个数，如果个数超过最大个数，清空res并更新max）
二叉搜索树中的插入操作（理解如何进行递归 递归三要素 1、确定参数和返回值 2、确定终止条件 3、确定单层递归逻辑）
删除二叉搜索树中的节点（当删除节点存在左右子节点时的操作，有时间可以理解迭代法）
修剪二叉搜索树（注意单层递归逻辑中，需要返回符合条件的左右子节点，不能单纯返回左右子节点，return trimBST(root->left, low, high) 而不是 return root->left）

寻找二叉树中到某节点的路径，若找到了路径需要在后面的回溯过程中直接返回，不再继续回溯
二叉搜索树的最近公共祖先（从上到下遍历，找到节点值在p、q之间即可返回不再进行递归，不需遍历整棵树，
                        和寻找节点路径类似，因此可以不用添加 root = nullptr 的终止条件，因为不会
                        遍历到叶子节点）
二叉树的最近公共祖先（需要定义l，r接住递归的返回值，需要遍历整棵树，与二叉搜索树不同，二叉搜索树题目说明了
                    一定待寻找的节点一定在树中，且二叉搜索树可以通过比较当前节点与p、q的值的大小判断是否是
                    公共节点，但是二叉树必须要找到l和r返回值均不为空的节点才可，因此需要遍历整棵树，即l有
                    返回值时r不一定有返回值，但是对于二叉搜索树，l有返回值则说明l是p、q的公共祖先，
                    所以，二叉树必须要处理叶子节点的情况，即需要有 root = nullptr的情况判断）

最长有效括号（动态规划：dp[i]，表示以i为结尾的最长长度，理解状态转移方程
            两次遍历：形如 "(()" 的一次遍历得不到结果（lc == rc时更新结果），再进行反向遍历取值较大的）
接雨水（双指针，一头一尾；
       单调栈（自己的解法），保存栈底，当 height[i] > bottom 时，全部弹出，将 height[i] 入栈，最后需要判断栈是否为空，不为空则弹出并进行更新
       单调栈，栈底到栈头从大到小，height[i] > height[s.top()] 时，mid = s.top()，s.pop()，计算凹槽的长和宽，计算面积
       动态规划，maxLeft 记录从左往右到 i 的最大高度，maxRight 记录从右往左到 i 的最大高度）
搜索旋转数组（细节没理清，需要复习）
字母异位词分组（unordered_map<string, vector<string>> mp，将每个排好序的字符作为key）
跳跃游戏（我用的动态规划，时间复杂度较高，
        可以用贪心(考虑范围是否能覆盖，利用循环条件 i <= range 判断是否能跳到点 i 上，在循环中更新range)）
k次取反后的最大化的数组和（按照绝对值大小进行排序 sort(nums.begin(), nums.end(), [&](int a, int b){return abs(a) < abs(b);})）
摆动序列（定义prediff记录前面的差，curdiff记录与后一位的差，注意curdiff和prediff的更新时间及符号判断）
买卖股票的最佳时机2（贪心，分解利润 p[3] - p[1] = p[3] - p[2] + p[2] - p[1]）
跳跃游戏2（需要复习）
颜色分类（双指针，red 从 0 开始，blue 从 n-1 开始，理清循环条件及交换条件）
合并二叉树（复习一下递归）
二叉树展开为链表（利用前序遍历，当栈不为空时，node = s.top()，node->right = s.top()，node->left = nullptr）
打家劫舍3（需要复习，利用 unordered_map 存储节点值，注意各个情况如何返回）
二叉树的直径（利用全局变量res记录最大值，注意dfs的返回值，dfs返回左子树和右子树中值较大的一个）
二叉树中的最大路径和（和二叉树的直径思想一样）
路径总和3（注意dfs的用法，之后可以思考回溯哪里有问题）
每日温度（单调栈，存储元素下标，T[i] 和 s.top() 的关系，分为三种情况讨论）
下一个更大的元素（nums1 是 nums2 的子集，利用 unordered_map 存储 nums1 中的元素，思路与每日温度一样）
下一个更大的元素2（i % nums.size()）
柱状图中最大的矩形（动态规划，同接雨水的动规类似，minLeftIndex 记录第i根柱子左边第一个高度小于该柱子的柱子下标，注意如何更新dp数组，需要复习
                  单调栈，接雨水中 i 是凹槽的右边界下标，s.top() 是凹槽的左边界下标，需要填满的长度是 i-s.top()-1，需要填满到高度 min(h[i], h[s.top()])
                        本题中，在 h 的左右两边各添加一个0，保证队列中元素从栈头到栈底是从小到大，处理思路与接雨水一致，保证新加入进来 h[i] 后
                        栈内元素依旧递增，弹出所有比 h[i] 大的元素，并计算他们的最大面积，左右两边都添加了0，可以保证全部出栈）
最大矩形（单调栈，柱状图中最大的矩形的进阶，定义二维数组 height , height[i][:] 表示第到 i 构成柱状图中各矩形的高度）
单词搜索（需要复习，定义一个可返回的 backtarce 函数，通过两个数组 {-1, 1, 0, 0}, {0, 0, 1, -1} 来表示方向）
合并区间（先排序）
最长连续序列（unordered_set<int> s 存储所有元素，取 cur = *s.begin()，如果 l = cur - 1 和 r = cur + 1 均存在，s.erase(l)，s.erase(r)，l --，r ++）
排序链表（归并排序，注意循环语句的退出条件 while(fast->next != nullptr && fast->next->next != nullptr)）
最小栈（利用辅助栈保存当前栈中最小元素，min_s.push(min(min_s.top(), val))）
LRU缓存机制（需要复习）
相交链表（while(a != b)，return a，若有相交，则返回a，若没有，a 和 b 会相交于链表末尾，即 nullptr）
多数元素（利用数组特性求解；利用快速排序求解）
