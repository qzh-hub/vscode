正则表达式匹配（注意 '*' 的情况，三种情况）
最长回文子串（中心扩散解法和动态规划解法）
全排列2
电话号码的字母组合
复原IP
分割回文串
回溯中的去重(树层去重和树枝去重)
N皇后
递增子序列(去重)
括号生成
三数之和
下一个排列
不同路径2，有障碍物如何进行初始化及状态转移
不同的二叉搜索树，如何构建转移方程
分割等和子集（体会将物品的价值和重量都设为数组元素的值，能否找到背包的最大值 等于 背包的重量）
目标和（如何将题目转化成01背包问题求解）
一和零（确定dp数组及其含义）
零钱兑换2（两层循环顺序是否可以调换）
组合总和4（背包问题，求组和 物品在外循环，背包在内循环， 求排列 背包在外循环，物品在内循环）
单词拆分（注意循环顺序）
打家劫舍2（成环该如何考虑，分类）
股票买卖系列（dp数组的含义理解）
最佳买卖股票时机含冷冻期（注意初始化）
最长重复子数组（滚动数组法中DP数组的含义，可以研究一下滑动窗口法）
不相交的线（将其转换成最长公共子序列问题）
不同的子序列（dp数组的含义，递推公式的推导，如何进行初始化）
回文子串（dp数组的含义，遍历顺序， 中心扩散解法）
最长回文子序列（dp数组的含义，遍历顺序）
二叉树的最小深度（注意最小深度的判断条件，需要是叶子节点）
完全二叉树的节点个数（如何利用完全二叉树的特点，找到满二叉树的子树，利用公式计算节点个数）
平衡二叉树（如何利用二叉树的深度求解解决，使用后序遍历的思想避免重复计算）
二叉树的所有路径（to_string函数，回溯的终止条件，迭代法的理解）
左叶子之和（理解返回值return curvalue + leftvalue + rightvalue）
找树左下角的值（理解递归终止条件，理解递归和回溯两种方法）
通过中序和后序遍历构造二叉树（弄清楚边界处理）

二叉搜索树：与中序遍历绑定思考

验证二叉搜索树（不能单一的判断左右子节点和父节点的值的大小，利用中序遍历，在遍历过程中比较）
二叉搜索树的最小绝对差（声明一个变量pre用于保存上一个节点）
二叉搜索树中的众数（利用pre保存上一个节点进行比较，利用全局变量记录个数和最大个数，如果个数超过最大个数，清空res并更新max）
二叉搜索树中的插入操作（理解如何进行递归 递归三要素 1、确定参数和返回值 2、确定终止条件 3、确定单层递归逻辑）
删除二叉搜索树中的节点（当删除节点存在左右子节点时的操作，有时间可以理解迭代法）
修剪二叉搜索树（注意单层递归逻辑中，需要返回符合条件的左右子节点，不能单纯返回左右子节点，return trimBST(root->left, low, high) 而不是 return root->left）

寻找二叉树中到某节点的路径，若找到了路径需要在后面的回溯过程中直接返回，不再继续回溯
二叉搜索树的最近公共祖先（从上到下遍历，找到节点值在p、q之间即可返回不再进行递归，不需遍历整棵树，
                        和寻找节点路径类似，因此可以不用添加 root = nullptr 的终止条件，因为不会
                        遍历到叶子节点）
二叉树的最近公共祖先（需要定义l，r接住递归的返回值，需要遍历整棵树，与二叉搜索树不同，二叉搜索树题目说明了
                    一定待寻找的节点一定在树中，且二叉搜索树可以通过比较当前节点与p、q的值的大小判断是否是
                    公共节点，但是二叉树必须要找到l和r返回值均不为空的节点才可，因此需要遍历整棵树，即l有
                    返回值时r不一定有返回值，但是对于二叉搜索树，l有返回值则说明l是p、q的公共祖先，
                    所以，二叉树必须要处理叶子节点的情况，即需要有 root = nullptr的情况判断）

最长有效括号（动态规划：dp[i]，表示以i为结尾的最长长度，理解状态转移方程
            两次遍历：形如 "(()" 的一次遍历得不到结果（lc == rc时更新结果），再进行反向遍历取值较大的）
接雨水（双指针，一头一尾）
搜索旋转数组（细节没理清，需要复习）
字母异位词分组（unordered_map<string, vector<string>> mp，将每个排好序的字符作为key）
跳跃游戏（我用的动态规划，时间复杂度较高，
        可以用贪心(考虑范围是否能覆盖，利用循环条件 i <= range 判断是否能跳到点 i 上，在循环中更新range)）
k次取反后的最大化的数组和（按照绝对值大小进行排序 sort(nums.begin(), nums.end(), [&](int a, int b){return abs(a) < abs(b);})）
摆动序列（定义prediff记录前面的差，curdiff记录与后一位的差，注意curdiff和prediff的更新时间及符号判断）
买卖股票的最佳时机2（贪心，分解利润 p[3] - p[1] = p[3] - p[2] + p[2] - p[1]）
跳跃游戏2（需要复习）
颜色分类（双指针，red 从 0 开始，blue 从 n-1 开始，理清循环条件及交换条件）
